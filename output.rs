extern crate alloc;
extern crate core;

pub use __cargo_equip::prelude::*;

pub mod treap {
    pub use crate::__cargo_equip::prelude::*;

    use slotmap::{new_key_type, Key, SlotMap};

    new_key_type! {
        pub struct NodeKey;
    }

    extern "C" {
        fn rand() -> std::os::raw::c_int;
    }

    /// totally random. not seeded
    fn randint() -> i32 {
        unsafe { rand() }
    }

    pub type KeyType = i64;

    #[derive(Debug)]
    pub struct Node {
        pub value: KeyType,
        pub priority: i32,
        pub count: usize,
        pub sum: KeyType,
        pub left: NodeKey,
        pub right: NodeKey,
        pub parent: NodeKey,
    }

    #[derive(Default)]
    pub struct Treap {
        nodes: SlotMap<NodeKey, Node>,
        root: NodeKey,
    }

    impl Node {
        pub fn new(value: KeyType) -> Self {
            Self::new_with_priority(value, randint())
        }

        pub fn new_with_priority(value: KeyType, priority: i32) -> Self {
            Self {
                value,
                priority,
                count: 1,
                sum: value,
                left: NodeKey::null(),
                right: NodeKey::null(),
                parent: NodeKey::null(),
            }
        }
    }

    impl Treap {
        pub fn new() -> Self {
            Self::default()
        }

        pub fn get(&self, node_key: NodeKey) -> Option<&Node> {
            self.nodes.get(node_key)
        }

        pub fn pull(&mut self, node_key: NodeKey) {
            let Node {
                value, left, right, ..
            } = self.nodes[node_key];

            let mut count = 1;
            let mut sum = value;
            if let Some(left) = self.nodes.get_mut(left) {
                count += left.count;
                sum += left.sum;
                left.parent = node_key;
            }
            if let Some(right) = self.nodes.get_mut(right) {
                count += right.count;
                sum += right.sum;
                right.parent = node_key;
            }

            let node = &mut self.nodes[node_key];
            node.count = count;
            node.sum = sum;
        }

        pub fn merge(&mut self, left: NodeKey, right: NodeKey) -> NodeKey {
            if !self.nodes.contains_key(left) {
                right
            } else if !self.nodes.contains_key(right) {
                left
            } else {
                let ref l = self.nodes[left];
                let ref r = self.nodes[right];

                if l.priority > r.priority {
                    self.nodes[left].right = self.merge(l.right, right);
                    self.pull(left);
                    left
                } else {
                    self.nodes[right].left = self.merge(left, r.left);
                    self.pull(right);
                    right
                }
            }
        }

        /// NOTE: does not clean up all parent links. prooobably fine
        pub fn split_node_at_value(
            &mut self,
            node_key: NodeKey,
            at: KeyType,
        ) -> (NodeKey, NodeKey) {
            if let Some(node) = self.nodes.get(node_key) {
                if node.value < at {
                    let (rl, rr) = self.split_node_at_value(node.right, at);
                    self.nodes[node_key].right = rl;
                    self.pull(node_key);
                    (node_key, rr)
                } else {
                    let (ll, lr) = self.split_node_at_value(node.left, at);
                    self.nodes[node_key].left = lr;
                    self.pull(node_key);
                    (ll, node_key)
                }
            } else {
                (NodeKey::null(), NodeKey::null())
            }
        }

        pub fn split_at_value(&mut self, at: KeyType) -> (NodeKey, NodeKey) {
            self.split_node_at_value(self.root, at)
        }

        pub fn insert_value(&mut self, value: KeyType) -> NodeKey {
            let new_node = self.nodes.insert(Node::new(value));
            let (left, right) = self.split_at_value(value);
            self.root = self.merge(left, new_node);
            self.root = self.merge(self.root, right);
            new_node
        }

        /// Returns NodeKey::null() if the value is not found.
        fn find_value_in_node(&self, node_key: NodeKey, value: i64) -> NodeKey {
            if let Some(node) = self.nodes.get(node_key) {
                if node.value == value {
                    node_key
                } else if node.value > value {
                    self.find_value_in_node(node.left, value)
                } else {
                    self.find_value_in_node(node.right, value)
                }
            } else {
                NodeKey::null()
            }
        }

        pub fn find_value(&self, value: KeyType) -> NodeKey {
            self.find_value_in_node(self.root, value)
        }

        pub fn remove_value(&mut self, value: KeyType) {
            let node = self.find_value(value);
            if node.is_null() {
                panic!("aaaaa");
            }

            let mut cur = self.nodes[node].parent;
            while let Some(node) = self.nodes.get_mut(cur) {
                node.count -= 1;
                node.sum -= value;
                cur = node.parent;
            }

            let Node {
                left,
                right,
                parent,
                ..
            } = self.nodes.remove(node).unwrap();

            let merged = self.merge(left, right);
            if let Some(merged) = self.nodes.get_mut(merged) {
                merged.parent = parent;
            }
            if let Some(parent) = self.nodes.get_mut(parent) {
                if parent.left == node {
                    parent.left = merged;
                } else {
                    parent.right = merged;
                }
            } else {
                self.root = merged;
            }
        }

        pub fn sum(&self) -> KeyType {
            if let Some(root) = self.nodes.get(self.root) {
                root.sum
            } else {
                0
            }
        }

        pub fn count(&self, node: NodeKey) -> usize {
            if let Some(node) = self.nodes.get(node) {
                node.count
            } else {
                0
            }
        }

        pub fn sum_of_n_greatest_in_node(&self, node_key: NodeKey, mut n: usize) -> KeyType {
            if let Some(node) = self.nodes.get(node_key) {
                if n == 0 {
                    return 0;
                } else if n >= node.count {
                    return node.sum;
                }

                let mut total = self.sum_of_n_greatest_in_node(node.right, n);
                n = n.saturating_sub(self.count(node.right));
                if n <= 0 {
                    return total;
                }
                total += node.value;
                n = n.saturating_sub(1);
                if n <= 0 {
                    return total;
                }
                total += self.sum_of_n_greatest_in_node(node.left, n);
                total
            } else {
                0
            }
        }

        pub fn sum_of_n_greatest(&self, n: usize) -> KeyType {
            self.sum_of_n_greatest_in_node(self.root, n)
        }

        pub fn iter(&self) -> Iter {
            Iter {
                stack: vec![],
                here: self.root,
                treap: self,
            }
        }

        pub fn visualise(&self) {
            pub fn go(nodes: &SlotMap<NodeKey, Node>, node: NodeKey, prefix: String) {
                if let Some(node) = nodes.get(node) {
                    println!("{prefix}value: {}", node.value);
                    println!("{prefix}count: {}", node.count);
                    println!("{prefix}sum: {}", node.sum);
                    println!("{prefix}priority: {}", node.priority);
                    println!("{prefix}left:");
                    go(nodes, node.left, prefix.clone() + "  ");
                    println!("{prefix}right:");
                    go(nodes, node.right, prefix + "  ");
                }
            }

            go(&self.nodes, self.root, "    ".into());
        }
    }

    pub struct Iter<'a> {
        stack: Vec<NodeKey>,
        here: NodeKey,
        treap: &'a Treap,
    }

    impl Iterator for Iter<'_> {
        type Item = NodeKey;

        fn next(&mut self) -> Option<Self::Item> {
            if !self.treap.nodes.contains_key(self.here) && self.stack.is_empty() {
                return None;
            }

            while let Some(node) = self.treap.nodes.get(self.here) {
                self.stack.push(self.here);
                self.here = node.left;
            }

            let next = self.stack.pop().unwrap();
            self.here = self.treap.nodes[next].right;

            Some(next)
        }
    }
}
use std::io::Read;

use treap::Treap;

fn main() {
    let mut input = String::new();
    std::io::stdin().read_to_string(&mut input).unwrap();
    let mut words = input.split_ascii_whitespace();

    macro_rules! read {
        ($ty:ty) => {{
            words.next().unwrap().parse::<$ty>().unwrap()
        }};
    }

    let n = read!(usize);
    let l = read!(usize);
    let k = read!(usize);
    let lst: Vec<i64> = words.take(n).map(|s| s.parse().unwrap()).collect();

    let mut set = Treap::new();

    for i in 0..l {
        set.insert_value(lst[i]);
    }

    let mut best = set.sum() - set.sum_of_n_greatest(k);

    for i in 0..n - l {
        set.remove_value(lst[i]);
        set.insert_value(lst[i + l]);

        best = best.min(set.sum() - set.sum_of_n_greatest(k));
    }

    println!("{best}");
}

// The following code was expanded by `cargo-equip`.

///  # Bundled libraries
/// 
///  - `slotmap 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)` licensed under `Zlib` as `crate::__cargo_equip::crates::slotmap`
#[cfg_attr(any(), rustfmt::skip)]
#[allow(unused)]
mod __cargo_equip {
    pub(crate) mod crates {
        pub mod slotmap {#![crate_name="slotmap"]#![cfg_attr(all(nightly,feature="unstable"),feature(try_reserve))]#![cfg_attr(all(not(test),not(feature="std")),no_std)]#![cfg_attr(all(nightly,doc),feature(doc_cfg))]#![warn(invalid_html_tags,missing_debug_implementations,trivial_casts,trivial_numeric_casts,unused_lifetimes,unused_import_braces)]#![deny(unaligned_references)]#![cfg_attr(feature="cargo-clippy",allow(renamed_and_removed_lints))]#![cfg_attr(feature="cargo-clippy",deny(clippy,clippy_pedantic))]#![cfg_attr(feature="cargo-clippy",allow(module_name_repetitions,redundant_closure_for_method_calls,unseparated_literal_suffix,wildcard_imports,inline_always,cast_possible_truncation,needless_pass_by_value,missing_errors_doc,must_use_candidate))]use crate::__cargo_equip::preludes::slotmap::*;pub use crate::__cargo_equip::macros::slotmap::*;extern crate alloc;pub mod basic{#![allow(unused_unsafe)]use crate::__cargo_equip::preludes::slotmap::*;#[cfg(all(nightly,any(doc,feature="unstable")))]use alloc::collections::TryReserveError;use alloc::vec::Vec;use core::fmt;use core::iter::{Enumerate,FusedIterator};use core::marker::PhantomData;#[allow(unused_imports)]use core::mem::{ManuallyDrop,MaybeUninit};use core::ops::{Index,IndexMut};use crate::__cargo_equip::crates::slotmap::{DefaultKey,Key,KeyData};union SlotUnion<T>{value:ManuallyDrop<T>,next_free:u32,}struct Slot<T>{u:SlotUnion<T>,version:u32,}enum SlotContent<'a,T:'a>{Occupied(&'a T),Vacant(&'a u32),}enum SlotContentMut<'a,T:'a>{OccupiedMut(&'a mut T),VacantMut(&'a mut u32),}use self::SlotContent::{Occupied,Vacant};use self::SlotContentMut::{OccupiedMut,VacantMut};impl<T>Slot<T>{#[inline(always)]pub fn occupied(&self)->bool{self.version%2>0}pub fn get(&self)->SlotContent<T>{unsafe{if self.occupied(){Occupied(&*self.u.value)}else{Vacant(&self.u.next_free)}}}pub fn get_mut(&mut self)->SlotContentMut<T>{unsafe{if self.occupied(){OccupiedMut(&mut*self.u.value)}else{VacantMut(&mut self.u.next_free)}}}}impl<T>Drop for Slot<T>{fn drop(&mut self){if core::mem::needs_drop::<T>()&&self.occupied(){unsafe{ManuallyDrop::drop(&mut self.u.value);}}}}impl<T:Clone>Clone for Slot<T>{fn clone(&self)->Self{Self{u:match self.get(){Occupied(value)=>SlotUnion{value:ManuallyDrop::new(value.clone()),},Vacant(&next_free)=>SlotUnion{next_free},},version:self.version,}}}impl<T:fmt::Debug>fmt::Debug for Slot<T>{fn fmt(&self,fmt:&mut fmt::Formatter)->fmt::Result{let mut builder=fmt.debug_struct("Slot");builder.field("version",&self.version);match self.get(){Occupied(value)=>builder.field("value",value).finish(),Vacant(next_free)=>builder.field("next_free",next_free).finish(),}}}#[derive(Debug,Clone)]pub struct SlotMap<K:Key,V>{slots:Vec<Slot<V>>,free_head:u32,num_elems:u32,_k:PhantomData<fn(K)->K>,}impl<V>SlotMap<DefaultKey,V>{pub fn new()->Self{Self::with_capacity_and_key(0)}pub fn with_capacity(capacity:usize)->Self{Self::with_capacity_and_key(capacity)}}impl<K:Key,V>SlotMap<K,V>{pub fn with_key()->Self{Self::with_capacity_and_key(0)}pub fn with_capacity_and_key(capacity:usize)->Self{let mut slots=Vec::with_capacity(capacity+1);slots.push(Slot{u:SlotUnion{next_free:0},version:0,});Self{slots,free_head:1,num_elems:0,_k:PhantomData,}}pub fn len(&self)->usize{self.num_elems as usize}pub fn is_empty(&self)->bool{self.num_elems==0}pub fn capacity(&self)->usize{self.slots.capacity()-1}pub fn reserve(&mut self,additional:usize){let needed=(self.len()+additional).saturating_sub(self.slots.len()-1);self.slots.reserve(needed);}#[cfg(all(nightly,any(doc,feature="unstable")))]#[cfg_attr(all(nightly,doc),doc(cfg(feature="unstable")))]pub fn try_reserve(&mut self,additional:usize)->Result<(),TryReserveError>{let needed=(self.len()+additional).saturating_sub(self.slots.len()-1);self.slots.try_reserve(needed)}pub fn contains_key(&self,key:K)->bool{let kd=key.data();self.slots.get(kd.idx as usize).map_or(false,|slot|slot.version==kd.version.get())}pub fn insert(&mut self,value:V)->K{self.insert_with_key(|_|value)}pub fn insert_with_key<F>(&mut self,f:F)->K where F:FnOnce(K)->V,{let new_num_elems=self.num_elems+1;if new_num_elems==core::u32::MAX{panic!("SlotMap number of elements overflow");}if let Some(slot)=self.slots.get_mut(self.free_head as usize){let occupied_version=slot.version|1;let kd=KeyData::new(self.free_head,occupied_version);let value=f(kd.into());unsafe{self.free_head=slot.u.next_free;slot.u.value=ManuallyDrop::new(value);slot.version=occupied_version;}self.num_elems=new_num_elems;return kd.into();}let version=1;let kd=KeyData::new(self.slots.len()as u32,version);self.slots.push(Slot{u:SlotUnion{value:ManuallyDrop::new(f(kd.into())),},version,});self.free_head=kd.idx+1;self.num_elems=new_num_elems;kd.into()}#[inline(always)]unsafe fn remove_from_slot(&mut self,idx:usize)->V{let slot=self.slots.get_unchecked_mut(idx);let value=ManuallyDrop::take(&mut slot.u.value);slot.u.next_free=self.free_head;self.free_head=idx as u32;self.num_elems-=1;slot.version=slot.version.wrapping_add(1);value}pub fn remove(&mut self,key:K)->Option<V>{let kd=key.data();if self.contains_key(key){Some(unsafe{self.remove_from_slot(kd.idx as usize)})}else{None}}pub fn retain<F>(&mut self,mut f:F)where F:FnMut(K,&mut V)->bool,{for i in 1..self.slots.len(){let slot=unsafe{self.slots.get_unchecked_mut(i)};let version=slot.version;let should_remove=if let OccupiedMut(value)=slot.get_mut(){let key=KeyData::new(i as u32,version).into();!f(key,value)}else{false};if should_remove{unsafe{self.remove_from_slot(i)};}}}pub fn clear(&mut self){self.drain();}pub fn drain(&mut self)->Drain<K,V>{Drain{cur:1,sm:self}}pub fn get(&self,key:K)->Option<&V>{let kd=key.data();self.slots.get(kd.idx as usize).filter(|slot|slot.version==kd.version.get()).map(|slot|unsafe{&*slot.u.value})}pub unsafe fn get_unchecked(&self,key:K)->&V{debug_assert!(self.contains_key(key));&self.slots.get_unchecked(key.data().idx as usize).u.value}pub fn get_mut(&mut self,key:K)->Option<&mut V>{let kd=key.data();self.slots.get_mut(kd.idx as usize).filter(|slot|slot.version==kd.version.get()).map(|slot|unsafe{&mut*slot.u.value})}pub unsafe fn get_unchecked_mut(&mut self,key:K)->&mut V{debug_assert!(self.contains_key(key));&mut self.slots.get_unchecked_mut(key.data().idx as usize).u.value}#[cfg(has_min_const_generics)]pub fn get_disjoint_mut<const N:usize>(&mut self,keys:[K;N])->Option<[&mut V;N]>{let mut ptrs:[MaybeUninit<*mut V>;N]=unsafe{MaybeUninit::uninit().assume_init()};let mut i=0;while i<N{let kd=keys[i].data();if!self.contains_key(kd.into()){break;}unsafe{let slot=self.slots.get_unchecked_mut(kd.idx as usize);slot.version^=1;ptrs[i]=MaybeUninit::new(&mut*slot.u.value);}i+=1;}for k in&keys[..i]{let idx=k.data().idx as usize;unsafe{self.slots.get_unchecked_mut(idx).version^=1;}}if i==N{Some(unsafe{core::mem::transmute_copy::<_,[&mut V;N]>(&ptrs)})}else{None}}#[cfg(has_min_const_generics)]pub unsafe fn get_disjoint_unchecked_mut<const N:usize>(&mut self,keys:[K;N],)->[&mut V;N]{let mut ptrs:[MaybeUninit<*mut V>;N]=MaybeUninit::uninit().assume_init();for i in 0..N{ptrs[i]=MaybeUninit::new(self.get_unchecked_mut(keys[i]));}core::mem::transmute_copy::<_,[&mut V;N]>(&ptrs)}pub fn iter(&self)->Iter<K,V>{let mut it=self.slots.iter().enumerate();it.next();Iter{slots:it,num_left:self.len(),_k:PhantomData,}}pub fn iter_mut(&mut self)->IterMut<K,V>{let len=self.len();let mut it=self.slots.iter_mut().enumerate();it.next();IterMut{num_left:len,slots:it,_k:PhantomData,}}pub fn keys(&self)->Keys<K,V>{Keys{inner:self.iter()}}pub fn values(&self)->Values<K,V>{Values{inner:self.iter()}}pub fn values_mut(&mut self)->ValuesMut<K,V>{ValuesMut{inner:self.iter_mut(),}}}impl<K:Key,V>Default for SlotMap<K,V>{fn default()->Self{Self::with_key()}}impl<K:Key,V>Index<K>for SlotMap<K,V>{type Output=V;fn index(&self,key:K)->&V{match self.get(key){Some(r)=>r,None=>panic!("invalid SlotMap key used"),}}}impl<K:Key,V>IndexMut<K>for SlotMap<K,V>{fn index_mut(&mut self,key:K)->&mut V{match self.get_mut(key){Some(r)=>r,None=>panic!("invalid SlotMap key used"),}}}#[derive(Debug)]pub struct Drain<'a,K:'a+Key,V:'a>{sm:&'a mut SlotMap<K,V>,cur:usize,}#[derive(Debug,Clone)]pub struct IntoIter<K:Key,V>{num_left:usize,slots:Enumerate<alloc::vec::IntoIter<Slot<V>>>,_k:PhantomData<fn(K)->K>,}#[derive(Debug,Clone)]pub struct Iter<'a,K:'a+Key,V:'a>{num_left:usize,slots:Enumerate<core::slice::Iter<'a,Slot<V>>>,_k:PhantomData<fn(K)->K>,}#[derive(Debug)]pub struct IterMut<'a,K:'a+Key,V:'a>{num_left:usize,slots:Enumerate<core::slice::IterMut<'a,Slot<V>>>,_k:PhantomData<fn(K)->K>,}#[derive(Debug,Clone)]pub struct Keys<'a,K:'a+Key,V:'a>{inner:Iter<'a,K,V>,}#[derive(Debug,Clone)]pub struct Values<'a,K:'a+Key,V:'a>{inner:Iter<'a,K,V>,}#[derive(Debug)]pub struct ValuesMut<'a,K:'a+Key,V:'a>{inner:IterMut<'a,K,V>,}impl<'a,K:Key,V>Iterator for Drain<'a,K,V>{type Item=(K,V);fn next(&mut self)->Option<(K,V)>{let len=self.sm.slots.len();while self.cur<len{let idx=self.cur;self.cur+=1;unsafe{let slot=self.sm.slots.get_unchecked(idx);if slot.occupied(){let kd=KeyData::new(idx as u32,slot.version);return Some((kd.into(),self.sm.remove_from_slot(idx)));}}}None}fn size_hint(&self)->(usize,Option<usize>){(self.sm.len(),Some(self.sm.len()))}}impl<'a,K:Key,V>Drop for Drain<'a,K,V>{fn drop(&mut self){self.for_each(|_drop|{});}}impl<K:Key,V>Iterator for IntoIter<K,V>{type Item=(K,V);fn next(&mut self)->Option<(K,V)>{while let Some((idx,mut slot))=self.slots.next(){if slot.occupied(){let kd=KeyData::new(idx as u32,slot.version);slot.version=0;let value=unsafe{ManuallyDrop::take(&mut slot.u.value)};self.num_left-=1;return Some((kd.into(),value));}}None}fn size_hint(&self)->(usize,Option<usize>){(self.num_left,Some(self.num_left))}}impl<'a,K:Key,V>Iterator for Iter<'a,K,V>{type Item=(K,&'a V);fn next(&mut self)->Option<(K,&'a V)>{while let Some((idx,slot))=self.slots.next(){if let Occupied(value)=slot.get(){let kd=KeyData::new(idx as u32,slot.version);self.num_left-=1;return Some((kd.into(),value));}}None}fn size_hint(&self)->(usize,Option<usize>){(self.num_left,Some(self.num_left))}}impl<'a,K:Key,V>Iterator for IterMut<'a,K,V>{type Item=(K,&'a mut V);fn next(&mut self)->Option<(K,&'a mut V)>{while let Some((idx,slot))=self.slots.next(){let version=slot.version;if let OccupiedMut(value)=slot.get_mut(){let kd=KeyData::new(idx as u32,version);self.num_left-=1;return Some((kd.into(),value));}}None}fn size_hint(&self)->(usize,Option<usize>){(self.num_left,Some(self.num_left))}}impl<'a,K:Key,V>Iterator for Keys<'a,K,V>{type Item=K;fn next(&mut self)->Option<K>{self.inner.next().map(|(key,_)|key)}fn size_hint(&self)->(usize,Option<usize>){self.inner.size_hint()}}impl<'a,K:Key,V>Iterator for Values<'a,K,V>{type Item=&'a V;fn next(&mut self)->Option<&'a V>{self.inner.next().map(|(_,value)|value)}fn size_hint(&self)->(usize,Option<usize>){self.inner.size_hint()}}impl<'a,K:Key,V>Iterator for ValuesMut<'a,K,V>{type Item=&'a mut V;fn next(&mut self)->Option<&'a mut V>{self.inner.next().map(|(_,value)|value)}fn size_hint(&self)->(usize,Option<usize>){self.inner.size_hint()}}impl<'a,K:Key,V>IntoIterator for&'a SlotMap<K,V>{type Item=(K,&'a V);type IntoIter=Iter<'a,K,V>;fn into_iter(self)->Self::IntoIter{self.iter()}}impl<'a,K:Key,V>IntoIterator for&'a mut SlotMap<K,V>{type Item=(K,&'a mut V);type IntoIter=IterMut<'a,K,V>;fn into_iter(self)->Self::IntoIter{self.iter_mut()}}impl<K:Key,V>IntoIterator for SlotMap<K,V>{type Item=(K,V);type IntoIter=IntoIter<K,V>;fn into_iter(self)->Self::IntoIter{let len=self.len();let mut it=self.slots.into_iter().enumerate();it.next();IntoIter{num_left:len,slots:it,_k:PhantomData,}}}impl<'a,K:Key,V>FusedIterator for Iter<'a,K,V>{}impl<'a,K:Key,V>FusedIterator for IterMut<'a,K,V>{}impl<'a,K:Key,V>FusedIterator for Keys<'a,K,V>{}impl<'a,K:Key,V>FusedIterator for Values<'a,K,V>{}impl<'a,K:Key,V>FusedIterator for ValuesMut<'a,K,V>{}impl<'a,K:Key,V>FusedIterator for Drain<'a,K,V>{}impl<K:Key,V>FusedIterator for IntoIter<K,V>{}impl<'a,K:Key,V>ExactSizeIterator for Iter<'a,K,V>{}impl<'a,K:Key,V>ExactSizeIterator for IterMut<'a,K,V>{}impl<'a,K:Key,V>ExactSizeIterator for Keys<'a,K,V>{}impl<'a,K:Key,V>ExactSizeIterator for Values<'a,K,V>{}impl<'a,K:Key,V>ExactSizeIterator for ValuesMut<'a,K,V>{}impl<'a,K:Key,V>ExactSizeIterator for Drain<'a,K,V>{}impl<K:Key,V>ExactSizeIterator for IntoIter<K,V>{}}pub mod dense{use crate::__cargo_equip::preludes::slotmap::*;#[cfg(all(nightly,any(doc,feature="unstable")))]use alloc::collections::TryReserveError;use alloc::vec::Vec;use core::iter::FusedIterator;#[allow(unused_imports)]use core::mem::MaybeUninit;use core::ops::{Index,IndexMut};use crate::__cargo_equip::crates::slotmap::{DefaultKey,Key,KeyData};#[derive(Debug,Clone)]struct Slot{version:u32,idx_or_free:u32,}#[derive(Debug,Clone)]pub struct DenseSlotMap<K:Key,V>{keys:Vec<K>,values:Vec<V>,slots:Vec<Slot>,free_head:u32,}impl<V>DenseSlotMap<DefaultKey,V>{pub fn new()->Self{Self::with_capacity_and_key(0)}pub fn with_capacity(capacity:usize)->DenseSlotMap<DefaultKey,V>{Self::with_capacity_and_key(capacity)}}impl<K:Key,V>DenseSlotMap<K,V>{pub fn with_key()->Self{Self::with_capacity_and_key(0)}pub fn with_capacity_and_key(capacity:usize)->Self{let mut slots=Vec::with_capacity(capacity+1);slots.push(Slot{idx_or_free:0,version:0,});DenseSlotMap{keys:Vec::with_capacity(capacity),values:Vec::with_capacity(capacity),slots,free_head:1,}}pub fn len(&self)->usize{self.keys.len()}pub fn is_empty(&self)->bool{self.keys.is_empty()}pub fn capacity(&self)->usize{self.keys.capacity()}pub fn reserve(&mut self,additional:usize){self.keys.reserve(additional);self.values.reserve(additional);let needed=(self.len()+additional).saturating_sub(self.slots.len()-1);self.slots.reserve(needed);}#[cfg(all(nightly,any(doc,feature="unstable")))]#[cfg_attr(all(nightly,doc),doc(cfg(feature="unstable")))]pub fn try_reserve(&mut self,additional:usize)->Result<(),TryReserveError>{self.keys.try_reserve(additional)?;self.values.try_reserve(additional)?;let needed=(self.len()+additional).saturating_sub(self.slots.len()-1);self.slots.try_reserve(needed)}pub fn contains_key(&self,key:K)->bool{let kd=key.data();self.slots.get(kd.idx as usize).map_or(false,|slot|slot.version==kd.version.get())}pub fn insert(&mut self,value:V)->K{self.insert_with_key(|_|value)}pub fn insert_with_key<F>(&mut self,f:F)->K where F:FnOnce(K)->V,{if self.len()>=(core::u32::MAX-1)as usize{panic!("DenseSlotMap number of elements overflow");}let idx=self.free_head;if let Some(slot)=self.slots.get_mut(idx as usize){let occupied_version=slot.version|1;let key=KeyData::new(idx,occupied_version).into();self.values.push(f(key));self.keys.push(key);self.free_head=slot.idx_or_free;slot.idx_or_free=self.keys.len()as u32-1;slot.version=occupied_version;return key;}let key=KeyData::new(idx,1).into();self.values.push(f(key));self.keys.push(key);self.slots.push(Slot{version:1,idx_or_free:self.keys.len()as u32-1,});self.free_head=self.slots.len()as u32;key}#[inline(always)]fn free_slot(&mut self,slot_idx:usize)->u32{let slot=&mut self.slots[slot_idx];let value_idx=slot.idx_or_free;slot.version=slot.version.wrapping_add(1);slot.idx_or_free=self.free_head;self.free_head=slot_idx as u32;value_idx}#[inline(always)]fn remove_from_slot(&mut self,slot_idx:usize)->V{let value_idx=self.free_slot(slot_idx);let _=self.keys.swap_remove(value_idx as usize);let value=self.values.swap_remove(value_idx as usize);if let Some(k)=self.keys.get(value_idx as usize){self.slots[k.data().idx as usize].idx_or_free=value_idx;}value}pub fn remove(&mut self,key:K)->Option<V>{let kd=key.data();if self.contains_key(kd.into()){Some(self.remove_from_slot(kd.idx as usize))}else{None}}pub fn retain<F>(&mut self,mut f:F)where F:FnMut(K,&mut V)->bool,{let mut i=0;while i<self.keys.len(){let(should_keep,slot_idx)={let(kd,mut value)=(self.keys[i].data(),&mut self.values[i]);(f(kd.into(),&mut value),kd.idx as usize)};if should_keep{i+=1;}else{self.remove_from_slot(slot_idx);}}}pub fn clear(&mut self){self.drain();}pub fn drain(&mut self)->Drain<K,V>{Drain{sm:self}}pub fn get(&self,key:K)->Option<&V>{let kd=key.data();self.slots.get(kd.idx as usize).filter(|slot|slot.version==kd.version.get()).map(|slot|unsafe{let idx=slot.idx_or_free as usize;self.values.get_unchecked(idx)})}pub unsafe fn get_unchecked(&self,key:K)->&V{debug_assert!(self.contains_key(key));let idx=self.slots.get_unchecked(key.data().idx as usize).idx_or_free;&self.values.get_unchecked(idx as usize)}pub fn get_mut(&mut self,key:K)->Option<&mut V>{let kd=key.data();self.slots.get(kd.idx as usize).filter(|slot|slot.version==kd.version.get()).map(|slot|slot.idx_or_free as usize).map(move|idx|unsafe{self.values.get_unchecked_mut(idx)})}pub unsafe fn get_unchecked_mut(&mut self,key:K)->&mut V{debug_assert!(self.contains_key(key));let idx=self.slots.get_unchecked(key.data().idx as usize).idx_or_free;self.values.get_unchecked_mut(idx as usize)}#[cfg(has_min_const_generics)]pub fn get_disjoint_mut<const N:usize>(&mut self,keys:[K;N])->Option<[&mut V;N]>{let mut ptrs:[MaybeUninit<*mut V>;N]=unsafe{MaybeUninit::uninit().assume_init()};let mut i=0;while i<N{let kd=keys[i].data();if!self.contains_key(kd.into()){break;}unsafe{let slot=self.slots.get_unchecked_mut(kd.idx as usize);slot.version^=1;let ptr=self.values.get_unchecked_mut(slot.idx_or_free as usize);ptrs[i]=MaybeUninit::new(ptr);}i+=1;}for k in&keys[..i]{let idx=k.data().idx as usize;unsafe{self.slots.get_unchecked_mut(idx).version^=1;}}if i==N{Some(unsafe{core::mem::transmute_copy::<_,[&mut V;N]>(&ptrs)})}else{None}}#[cfg(has_min_const_generics)]pub unsafe fn get_disjoint_unchecked_mut<const N:usize>(&mut self,keys:[K;N],)->[&mut V;N]{let mut ptrs:[MaybeUninit<*mut V>;N]=MaybeUninit::uninit().assume_init();for i in 0..N{ptrs[i]=MaybeUninit::new(self.get_unchecked_mut(keys[i]));}core::mem::transmute_copy::<_,[&mut V;N]>(&ptrs)}pub fn iter(&self)->Iter<K,V>{Iter{inner_keys:self.keys.iter(),inner_values:self.values.iter(),}}pub fn iter_mut(&mut self)->IterMut<K,V>{IterMut{inner_keys:self.keys.iter(),inner_values:self.values.iter_mut(),}}pub fn keys(&self)->Keys<K,V>{Keys{inner:self.iter()}}pub fn values(&self)->Values<K,V>{Values{inner:self.iter()}}pub fn values_mut(&mut self)->ValuesMut<K,V>{ValuesMut{inner:self.iter_mut(),}}}impl<K:Key,V>Default for DenseSlotMap<K,V>{fn default()->Self{Self::with_key()}}impl<K:Key,V>Index<K>for DenseSlotMap<K,V>{type Output=V;fn index(&self,key:K)->&V{match self.get(key){Some(r)=>r,None=>panic!("invalid DenseSlotMap key used"),}}}impl<K:Key,V>IndexMut<K>for DenseSlotMap<K,V>{fn index_mut(&mut self,key:K)->&mut V{match self.get_mut(key){Some(r)=>r,None=>panic!("invalid DenseSlotMap key used"),}}}#[derive(Debug)]pub struct Drain<'a,K:'a+Key,V:'a>{sm:&'a mut DenseSlotMap<K,V>,}#[derive(Debug,Clone)]pub struct IntoIter<K,V>{inner_keys:alloc::vec::IntoIter<K>,inner_values:alloc::vec::IntoIter<V>,}#[derive(Debug,Clone)]pub struct Iter<'a,K:'a+Key,V:'a>{inner_keys:core::slice::Iter<'a,K>,inner_values:core::slice::Iter<'a,V>,}#[derive(Debug)]pub struct IterMut<'a,K:'a+Key,V:'a>{inner_keys:core::slice::Iter<'a,K>,inner_values:core::slice::IterMut<'a,V>,}#[derive(Debug,Clone)]pub struct Keys<'a,K:'a+Key,V>{inner:Iter<'a,K,V>,}#[derive(Debug,Clone)]pub struct Values<'a,K:'a+Key,V>{inner:Iter<'a,K,V>,}#[derive(Debug)]pub struct ValuesMut<'a,K:'a+Key,V:'a>{inner:IterMut<'a,K,V>,}impl<'a,K:Key,V>Iterator for Drain<'a,K,V>{type Item=(K,V);fn next(&mut self)->Option<(K,V)>{let key=self.sm.keys.pop();let value=self.sm.values.pop();if let(Some(k),Some(v))=(key,value){self.sm.free_slot(k.data().idx as usize);Some((k,v))}else{None}}fn size_hint(&self)->(usize,Option<usize>){let len=self.sm.keys.len();(len,Some(len))}}impl<'a,K:Key,V>Drop for Drain<'a,K,V>{fn drop(&mut self){self.for_each(|_drop|{});}}impl<K:Key,V>Iterator for IntoIter<K,V>{type Item=(K,V);fn next(&mut self)->Option<(K,V)>{let key=self.inner_keys.next();let value=self.inner_values.next();if let(Some(k),Some(v))=(key,value){Some((k,v))}else{None}}fn size_hint(&self)->(usize,Option<usize>){self.inner_keys.size_hint()}}impl<'a,K:'a+Key,V>Iterator for Iter<'a,K,V>{type Item=(K,&'a V);fn next(&mut self)->Option<(K,&'a V)>{let key=self.inner_keys.next();let value=self.inner_values.next();if let(Some(k),Some(v))=(key,value){Some((*k,v))}else{None}}fn size_hint(&self)->(usize,Option<usize>){self.inner_keys.size_hint()}}impl<'a,K:'a+Key,V>Iterator for IterMut<'a,K,V>{type Item=(K,&'a mut V);fn next(&mut self)->Option<(K,&'a mut V)>{let key=self.inner_keys.next();let value=self.inner_values.next();if let(Some(k),Some(v))=(key,value){Some((*k,v))}else{None}}fn size_hint(&self)->(usize,Option<usize>){self.inner_keys.size_hint()}}impl<'a,K:'a+Key,V>Iterator for Keys<'a,K,V>{type Item=K;fn next(&mut self)->Option<K>{self.inner.next().map(|(key,_)|key)}fn size_hint(&self)->(usize,Option<usize>){self.inner.size_hint()}}impl<'a,K:'a+Key,V>Iterator for Values<'a,K,V>{type Item=&'a V;fn next(&mut self)->Option<&'a V>{self.inner.next().map(|(_,value)|value)}fn size_hint(&self)->(usize,Option<usize>){self.inner.size_hint()}}impl<'a,K:'a+Key,V>Iterator for ValuesMut<'a,K,V>{type Item=&'a mut V;fn next(&mut self)->Option<&'a mut V>{self.inner.next().map(|(_,value)|value)}fn size_hint(&self)->(usize,Option<usize>){self.inner.size_hint()}}impl<'a,K:'a+Key,V>IntoIterator for&'a DenseSlotMap<K,V>{type Item=(K,&'a V);type IntoIter=Iter<'a,K,V>;fn into_iter(self)->Self::IntoIter{self.iter()}}impl<'a,K:'a+Key,V>IntoIterator for&'a mut DenseSlotMap<K,V>{type Item=(K,&'a mut V);type IntoIter=IterMut<'a,K,V>;fn into_iter(self)->Self::IntoIter{self.iter_mut()}}impl<K:Key,V>IntoIterator for DenseSlotMap<K,V>{type Item=(K,V);type IntoIter=IntoIter<K,V>;fn into_iter(self)->Self::IntoIter{IntoIter{inner_keys:self.keys.into_iter(),inner_values:self.values.into_iter(),}}}impl<'a,K:'a+Key,V>FusedIterator for Iter<'a,K,V>{}impl<'a,K:'a+Key,V>FusedIterator for IterMut<'a,K,V>{}impl<'a,K:'a+Key,V>FusedIterator for Keys<'a,K,V>{}impl<'a,K:'a+Key,V>FusedIterator for Values<'a,K,V>{}impl<'a,K:'a+Key,V>FusedIterator for ValuesMut<'a,K,V>{}impl<'a,K:'a+Key,V>FusedIterator for Drain<'a,K,V>{}impl<K:Key,V>FusedIterator for IntoIter<K,V>{}impl<'a,K:'a+Key,V>ExactSizeIterator for Iter<'a,K,V>{}impl<'a,K:'a+Key,V>ExactSizeIterator for IterMut<'a,K,V>{}impl<'a,K:'a+Key,V>ExactSizeIterator for Keys<'a,K,V>{}impl<'a,K:'a+Key,V>ExactSizeIterator for Values<'a,K,V>{}impl<'a,K:'a+Key,V>ExactSizeIterator for ValuesMut<'a,K,V>{}impl<'a,K:'a+Key,V>ExactSizeIterator for Drain<'a,K,V>{}impl<K:Key,V>ExactSizeIterator for IntoIter<K,V>{}}pub mod hop{#![allow(unused_unsafe)]use crate::__cargo_equip::preludes::slotmap::*;#[cfg(all(nightly,any(doc,feature="unstable")))]use alloc::collections::TryReserveError;use alloc::vec::Vec;use core::fmt;use core::iter::FusedIterator;use core::marker::PhantomData;use core::mem::ManuallyDrop;#[allow(unused_imports)]use core::mem::MaybeUninit;use core::ops::{Index,IndexMut};use crate::__cargo_equip::crates::slotmap::{DefaultKey,Key,KeyData};#[derive(Clone,Copy,Debug)]struct FreeListEntry{next:u32,prev:u32,other_end:u32,}union SlotUnion<T>{value:ManuallyDrop<T>,free:FreeListEntry,}struct Slot<T>{u:SlotUnion<T>,version:u32,}enum SlotContent<'a,T:'a>{Occupied(&'a T),Vacant(&'a FreeListEntry),}use self::SlotContent::{Occupied,Vacant};impl<T>Slot<T>{#[inline(always)]pub fn occupied(&self)->bool{self.version%2==1}pub fn get(&self)->SlotContent<T>{unsafe{if self.occupied(){Occupied(&*self.u.value)}else{Vacant(&self.u.free)}}}}impl<T>Drop for Slot<T>{fn drop(&mut self){if core::mem::needs_drop::<T>()&&self.occupied(){unsafe{ManuallyDrop::drop(&mut self.u.value);}}}}impl<T:Clone>Clone for Slot<T>{fn clone(&self)->Self{Self{u:match self.get(){Occupied(value)=>SlotUnion{value:ManuallyDrop::new(value.clone()),},Vacant(&free)=>SlotUnion{free},},version:self.version,}}}impl<T:fmt::Debug>fmt::Debug for Slot<T>{fn fmt(&self,fmt:&mut fmt::Formatter)->fmt::Result{let mut builder=fmt.debug_struct("Slot");builder.field("version",&self.version);match self.get(){Occupied(value)=>builder.field("value",value).finish(),Vacant(free)=>builder.field("free",free).finish(),}}}#[derive(Debug,Clone)]pub struct HopSlotMap<K:Key,V>{slots:Vec<Slot<V>>,num_elems:u32,_k:PhantomData<fn(K)->K>,}impl<V>HopSlotMap<DefaultKey,V>{pub fn new()->Self{Self::with_capacity_and_key(0)}pub fn with_capacity(capacity:usize)->Self{Self::with_capacity_and_key(capacity)}}impl<K:Key,V>HopSlotMap<K,V>{pub fn with_key()->Self{Self::with_capacity_and_key(0)}pub fn with_capacity_and_key(capacity:usize)->Self{let mut slots=Vec::with_capacity(capacity+1);slots.push(Slot{u:SlotUnion{free:FreeListEntry{next:0,prev:0,other_end:0,},},version:0,});Self{slots,num_elems:0,_k:PhantomData,}}pub fn len(&self)->usize{self.num_elems as usize}pub fn is_empty(&self)->bool{self.num_elems==0}pub fn capacity(&self)->usize{self.slots.capacity()-1}pub fn reserve(&mut self,additional:usize){let needed=(self.len()+additional).saturating_sub(self.slots.len()-1);self.slots.reserve(needed);}#[cfg(all(nightly,any(doc,feature="unstable")))]#[cfg_attr(all(nightly,doc),doc(cfg(feature="unstable")))]pub fn try_reserve(&mut self,additional:usize)->Result<(),TryReserveError>{let needed=(self.len()+additional).saturating_sub(self.slots.len()-1);self.slots.try_reserve(needed)}pub fn contains_key(&self,key:K)->bool{let kd=key.data();self.slots.get(kd.idx as usize).map_or(false,|slot|slot.version==kd.version.get())}pub fn insert(&mut self,value:V)->K{self.insert_with_key(|_|value)}unsafe fn freelist(&mut self,idx:u32)->&mut FreeListEntry{&mut self.slots.get_unchecked_mut(idx as usize).u.free}pub fn insert_with_key<F>(&mut self,f:F)->K where F:FnOnce(K)->V,{let new_num_elems=self.num_elems+1;if new_num_elems==core::u32::MAX{panic!("HopSlotMap number of elements overflow");}unsafe{let head=self.freelist(0).next;let front=head;let back=self.freelist(front).other_end;let slot_idx=back as usize;if slot_idx==0{let version=1;let key=KeyData::new(self.slots.len()as u32,version).into();self.slots.push(Slot{u:SlotUnion{value:ManuallyDrop::new(f(key)),},version,});self.num_elems=new_num_elems;return key;}let occupied_version=self.slots[slot_idx].version|1;let key=KeyData::new(slot_idx as u32,occupied_version).into();let value=f(key);if front==back{let new_head=self.freelist(front).next;self.freelist(0).next=new_head;self.freelist(new_head).prev=0;}else{let new_back=back-1;self.freelist(new_back).other_end=front;self.freelist(front).other_end=new_back;}let slot=&mut self.slots[slot_idx];slot.version=occupied_version;slot.u.value=ManuallyDrop::new(value);self.num_elems=new_num_elems;key}}#[inline(always)]unsafe fn remove_from_slot(&mut self,idx:usize)->V{let slot=self.slots.get_unchecked_mut(idx);slot.version=slot.version.wrapping_add(1);let value=ManuallyDrop::take(&mut slot.u.value);let left_vacant=!self.slots.get_unchecked(idx-1).occupied();let right_vacant=self.slots.get(idx+1).map_or(false,|s|!s.occupied());let i=idx as u32;match(left_vacant,right_vacant){(false,false)=>{let old_tail=self.freelist(0).prev;self.freelist(0).prev=i;self.freelist(old_tail).next=i;*self.freelist(i)=FreeListEntry{other_end:i,next:0,prev:old_tail,};}(false,true)=>{let front_data=*self.freelist(i+1);self.freelist(front_data.other_end).other_end=i;self.freelist(front_data.prev).next=i;self.freelist(front_data.next).prev=i;*self.freelist(i)=front_data;}(true,false)=>{let front=self.freelist(i-1).other_end;self.freelist(i).other_end=front;self.freelist(front).other_end=i;}(true,true)=>{let right=*self.freelist(i+1);self.freelist(right.prev).next=right.next;self.freelist(right.next).prev=right.prev;let front=self.freelist(i-1).other_end;let back=right.other_end;self.freelist(front).other_end=back;self.freelist(back).other_end=front;}}self.num_elems-=1;value}pub fn remove(&mut self,key:K)->Option<V>{let kd=key.data();if self.contains_key(key){Some(unsafe{self.remove_from_slot(kd.idx as usize)})}else{None}}pub fn retain<F>(&mut self,mut f:F)where F:FnMut(K,&mut V)->bool,{let mut elems_left_to_scan=self.len();let mut cur=unsafe{self.slots.get_unchecked(0).u.free.other_end as usize+1};while elems_left_to_scan>0{let idx=cur;let slot=unsafe{self.slots.get_unchecked_mut(cur)};let version=slot.version;let key=KeyData::new(cur as u32,version).into();let should_remove=!f(key,unsafe{&mut*slot.u.value});cur=match self.slots.get(cur+1).map(|s|s.get()){Some(Occupied(_))=>cur+1,Some(Vacant(free))=>free.other_end as usize+1,None=>0,};if should_remove{unsafe{self.remove_from_slot(idx)};}elems_left_to_scan-=1;}}pub fn clear(&mut self){self.drain();}pub fn drain(&mut self)->Drain<K,V>{Drain{cur:unsafe{self.slots.get_unchecked(0).u.free.other_end as usize+1},sm:self,}}pub fn get(&self,key:K)->Option<&V>{let kd=key.data();self.slots.get(kd.idx as usize).filter(|slot|slot.version==kd.version.get()).map(|slot|unsafe{&*slot.u.value})}pub unsafe fn get_unchecked(&self,key:K)->&V{debug_assert!(self.contains_key(key));&self.slots.get_unchecked(key.data().idx as usize).u.value}pub fn get_mut(&mut self,key:K)->Option<&mut V>{let kd=key.data();self.slots.get_mut(kd.idx as usize).filter(|slot|slot.version==kd.version.get()).map(|slot|unsafe{&mut*slot.u.value})}pub unsafe fn get_unchecked_mut(&mut self,key:K)->&mut V{debug_assert!(self.contains_key(key));&mut self.slots.get_unchecked_mut(key.data().idx as usize).u.value}#[cfg(has_min_const_generics)]pub fn get_disjoint_mut<const N:usize>(&mut self,keys:[K;N])->Option<[&mut V;N]>{let mut ptrs:[MaybeUninit<*mut V>;N]=unsafe{MaybeUninit::uninit().assume_init()};let mut i=0;while i<N{let kd=keys[i].data();if!self.contains_key(kd.into()){break;}unsafe{let slot=self.slots.get_unchecked_mut(kd.idx as usize);slot.version^=1;ptrs[i]=MaybeUninit::new(&mut*slot.u.value);}i+=1;}for k in&keys[..i]{let idx=k.data().idx as usize;unsafe{self.slots.get_unchecked_mut(idx).version^=1;}}if i==N{Some(unsafe{core::mem::transmute_copy::<_,[&mut V;N]>(&ptrs)})}else{None}}#[cfg(has_min_const_generics)]pub unsafe fn get_disjoint_unchecked_mut<const N:usize>(&mut self,keys:[K;N],)->[&mut V;N]{let mut ptrs:[MaybeUninit<*mut V>;N]=MaybeUninit::uninit().assume_init();for i in 0..N{ptrs[i]=MaybeUninit::new(self.get_unchecked_mut(keys[i]));}core::mem::transmute_copy::<_,[&mut V;N]>(&ptrs)}pub fn iter(&self)->Iter<K,V>{Iter{cur:unsafe{self.slots.get_unchecked(0).u.free.other_end as usize+1},num_left:self.len(),slots:&self.slots[..],_k:PhantomData,}}pub fn iter_mut(&mut self)->IterMut<K,V>{IterMut{cur:0,num_left:self.len(),slots:&mut self.slots[..],_k:PhantomData,}}pub fn keys(&self)->Keys<K,V>{Keys{inner:self.iter()}}pub fn values(&self)->Values<K,V>{Values{inner:self.iter()}}pub fn values_mut(&mut self)->ValuesMut<K,V>{ValuesMut{inner:self.iter_mut(),}}}impl<K:Key,V>Default for HopSlotMap<K,V>{fn default()->Self{Self::with_key()}}impl<K:Key,V>Index<K>for HopSlotMap<K,V>{type Output=V;fn index(&self,key:K)->&V{match self.get(key){Some(r)=>r,None=>panic!("invalid HopSlotMap key used"),}}}impl<K:Key,V>IndexMut<K>for HopSlotMap<K,V>{fn index_mut(&mut self,key:K)->&mut V{match self.get_mut(key){Some(r)=>r,None=>panic!("invalid HopSlotMap key used"),}}}#[derive(Debug)]pub struct Drain<'a,K:Key+'a,V:'a>{cur:usize,sm:&'a mut HopSlotMap<K,V>,}#[derive(Debug,Clone)]pub struct IntoIter<K:Key,V>{cur:usize,num_left:usize,slots:Vec<Slot<V>>,_k:PhantomData<fn(K)->K>,}#[derive(Debug,Clone)]pub struct Iter<'a,K:Key+'a,V:'a>{cur:usize,num_left:usize,slots:&'a[Slot<V>],_k:PhantomData<fn(K)->K>,}#[derive(Debug)]pub struct IterMut<'a,K:Key+'a,V:'a>{cur:usize,num_left:usize,slots:&'a mut[Slot<V>],_k:PhantomData<fn(K)->K>,}#[derive(Debug,Clone)]pub struct Keys<'a,K:Key+'a,V:'a>{inner:Iter<'a,K,V>,}#[derive(Debug,Clone)]pub struct Values<'a,K:Key+'a,V:'a>{inner:Iter<'a,K,V>,}#[derive(Debug)]pub struct ValuesMut<'a,K:Key+'a,V:'a>{inner:IterMut<'a,K,V>,}impl<'a,K:Key,V>Iterator for Drain<'a,K,V>{type Item=(K,V);fn next(&mut self)->Option<(K,V)>{if self.sm.len()==0{return None;}let idx=self.cur;self.cur=match self.sm.slots.get(idx+1).map(|s|s.get()){Some(Occupied(_))=>idx+1,Some(Vacant(free))=>free.other_end as usize+1,None=>0,};let key=KeyData::new(idx as u32,unsafe{self.sm.slots.get_unchecked(idx).version});Some((key.into(),unsafe{self.sm.remove_from_slot(idx)}))}fn size_hint(&self)->(usize,Option<usize>){(self.sm.len(),Some(self.sm.len()))}}impl<'a,K:Key,V>Drop for Drain<'a,K,V>{fn drop(&mut self){self.for_each(|_drop|{});}}impl<K:Key,V>Iterator for IntoIter<K,V>{type Item=(K,V);fn next(&mut self)->Option<(K,V)>{if self.cur>=self.slots.len(){return None;}let idx=match self.slots[self.cur].get(){Occupied(_)=>self.cur,Vacant(free)=>{let idx=free.other_end as usize+1;if idx>=self.slots.len(){return None;}idx}};self.cur=idx+1;self.num_left-=1;let slot=&mut self.slots[idx];let key=KeyData::new(idx as u32,slot.version).into();slot.version=0;Some((key,unsafe{ManuallyDrop::take(&mut slot.u.value)}))}fn size_hint(&self)->(usize,Option<usize>){(self.num_left,Some(self.num_left))}}impl<'a,K:Key,V>Iterator for Iter<'a,K,V>{type Item=(K,&'a V);fn next(&mut self)->Option<(K,&'a V)>{if self.num_left==0{return None;}self.num_left-=1;let idx=match unsafe{self.slots.get_unchecked(self.cur).get()}{Occupied(_)=>self.cur,Vacant(free)=>free.other_end as usize+1,};self.cur=idx+1;let slot=unsafe{self.slots.get_unchecked(idx)};let key=KeyData::new(idx as u32,slot.version).into();Some((key,unsafe{&*slot.u.value}))}fn size_hint(&self)->(usize,Option<usize>){(self.num_left,Some(self.num_left))}}impl<'a,K:Key,V>Iterator for IterMut<'a,K,V>{type Item=(K,&'a mut V);fn next(&mut self)->Option<(K,&'a mut V)>{if self.cur>=self.slots.len(){return None;}let idx=match self.slots[self.cur].get(){Occupied(_)=>self.cur,Vacant(free)=>{let idx=free.other_end as usize+1;if idx>=self.slots.len(){return None;}idx}};self.cur=idx+1;self.num_left-=1;let slot=&mut self.slots[idx];let version=slot.version;let value_ref=unsafe{let ptr:*mut V=&mut*slot.u.value;&mut*ptr};Some((KeyData::new(idx as u32,version).into(),value_ref))}fn size_hint(&self)->(usize,Option<usize>){(self.num_left,Some(self.num_left))}}impl<'a,K:Key,V>Iterator for Keys<'a,K,V>{type Item=K;fn next(&mut self)->Option<K>{self.inner.next().map(|(key,_)|key)}fn size_hint(&self)->(usize,Option<usize>){self.inner.size_hint()}}impl<'a,K:Key,V>Iterator for Values<'a,K,V>{type Item=&'a V;fn next(&mut self)->Option<&'a V>{self.inner.next().map(|(_,value)|value)}fn size_hint(&self)->(usize,Option<usize>){self.inner.size_hint()}}impl<'a,K:Key,V>Iterator for ValuesMut<'a,K,V>{type Item=&'a mut V;fn next(&mut self)->Option<&'a mut V>{self.inner.next().map(|(_,value)|value)}fn size_hint(&self)->(usize,Option<usize>){self.inner.size_hint()}}impl<'a,K:Key,V>IntoIterator for&'a HopSlotMap<K,V>{type Item=(K,&'a V);type IntoIter=Iter<'a,K,V>;fn into_iter(self)->Self::IntoIter{self.iter()}}impl<'a,K:Key,V>IntoIterator for&'a mut HopSlotMap<K,V>{type Item=(K,&'a mut V);type IntoIter=IterMut<'a,K,V>;fn into_iter(self)->Self::IntoIter{self.iter_mut()}}impl<K:Key,V>IntoIterator for HopSlotMap<K,V>{type Item=(K,V);type IntoIter=IntoIter<K,V>;fn into_iter(self)->Self::IntoIter{IntoIter{cur:0,num_left:self.len(),slots:self.slots,_k:PhantomData,}}}impl<'a,K:Key,V>FusedIterator for Iter<'a,K,V>{}impl<'a,K:Key,V>FusedIterator for IterMut<'a,K,V>{}impl<'a,K:Key,V>FusedIterator for Keys<'a,K,V>{}impl<'a,K:Key,V>FusedIterator for Values<'a,K,V>{}impl<'a,K:Key,V>FusedIterator for ValuesMut<'a,K,V>{}impl<'a,K:Key,V>FusedIterator for Drain<'a,K,V>{}impl<K:Key,V>FusedIterator for IntoIter<K,V>{}impl<'a,K:Key,V>ExactSizeIterator for Iter<'a,K,V>{}impl<'a,K:Key,V>ExactSizeIterator for IterMut<'a,K,V>{}impl<'a,K:Key,V>ExactSizeIterator for Keys<'a,K,V>{}impl<'a,K:Key,V>ExactSizeIterator for Values<'a,K,V>{}impl<'a,K:Key,V>ExactSizeIterator for ValuesMut<'a,K,V>{}impl<'a,K:Key,V>ExactSizeIterator for Drain<'a,K,V>{}impl<K:Key,V>ExactSizeIterator for IntoIter<K,V>{}}pub mod secondary{use crate::__cargo_equip::preludes::slotmap::*;use super::{is_older_version,Key,KeyData};#[cfg(all(nightly,any(doc,feature="unstable")))]use alloc::collections::TryReserveError;use alloc::vec::Vec;use core::hint::unreachable_unchecked;use core::iter::{Enumerate,Extend,FromIterator,FusedIterator};use core::marker::PhantomData;use core::mem::replace;#[allow(unused_imports)]use core::mem::MaybeUninit;use core::num::NonZeroU32;use core::ops::{Index,IndexMut};#[derive(Debug,Clone)]enum Slot<T>{Occupied{value:T,version:NonZeroU32},Vacant,}use self::Slot::Occupied;use self::Slot::Vacant;impl<T>Slot<T>{pub fn new_occupied(version:u32,value:T)->Self{Occupied{value,version:unsafe{NonZeroU32::new_unchecked(version|1u32)},}}pub fn new_vacant()->Self{Vacant}#[inline(always)]pub fn occupied(&self)->bool{match self{Occupied{..}=>true,Vacant=>false,}}#[inline(always)]pub fn version(&self)->u32{match self{Occupied{version,..}=>version.get(),Vacant=>0,}}pub unsafe fn get_unchecked(&self)->&T{match self{Occupied{value,..}=>value,Vacant=>unreachable_unchecked(),}}pub unsafe fn get_unchecked_mut(&mut self)->&mut T{match self{Occupied{value,..}=>value,Vacant=>unreachable_unchecked(),}}pub fn into_option(self)->Option<T>{match self{Occupied{value,..}=>Some(value),Vacant=>None,}}}#[derive(Debug,Clone)]pub struct SecondaryMap<K:Key,V>{slots:Vec<Slot<V>>,num_elems:usize,_k:PhantomData<fn(K)->K>,}impl<K:Key,V>SecondaryMap<K,V>{pub fn new()->Self{Self::with_capacity(0)}pub fn with_capacity(capacity:usize)->Self{let mut slots=Vec::with_capacity(capacity+1);slots.push(Slot::new_vacant());Self{slots,num_elems:0,_k:PhantomData,}}pub fn len(&self)->usize{self.num_elems}pub fn is_empty(&self)->bool{self.num_elems==0}pub fn capacity(&self)->usize{self.slots.capacity()-1}pub fn set_capacity(&mut self,new_capacity:usize){let new_capacity=new_capacity+1;if new_capacity>self.slots.capacity(){let needed=new_capacity-self.slots.len();self.slots.reserve(needed);}}#[cfg(all(nightly,any(doc,feature="unstable")))]#[cfg_attr(all(nightly,doc),doc(cfg(feature="unstable")))]pub fn try_set_capacity(&mut self,new_capacity:usize)->Result<(),TryReserveError>{let new_capacity=new_capacity+1;if new_capacity>self.slots.capacity(){let needed=new_capacity-self.slots.len();self.slots.try_reserve(needed)}else{Ok(())}}pub fn contains_key(&self,key:K)->bool{let kd=key.data();self.slots.get(kd.idx as usize).map_or(false,|slot|slot.version()==kd.version.get())}pub fn insert(&mut self,key:K,value:V)->Option<V>{if key.is_null(){return None;}let kd=key.data();self.slots.extend((self.slots.len()..=kd.idx as usize).map(|_|Slot::new_vacant()));let slot=&mut self.slots[kd.idx as usize];if slot.version()==kd.version.get(){return Some(replace(unsafe{slot.get_unchecked_mut()},value));}if slot.occupied(){if is_older_version(kd.version.get(),slot.version()){return None;}}else{self.num_elems+=1;}*slot=Slot::new_occupied(kd.version.get(),value);None}pub fn remove(&mut self,key:K)->Option<V>{let kd=key.data();if let Some(slot)=self.slots.get_mut(kd.idx as usize){if slot.version()==kd.version.get(){self.num_elems-=1;return replace(slot,Slot::new_vacant()).into_option();}}None}pub fn retain<F>(&mut self,mut f:F)where F:FnMut(K,&mut V)->bool,{for(i,slot)in self.slots.iter_mut().enumerate(){if let Occupied{value,version}=slot{let key=KeyData::new(i as u32,version.get()).into();if!f(key,value){self.num_elems-=1;*slot=Slot::new_vacant();}}}}pub fn clear(&mut self){self.drain();}pub fn drain(&mut self)->Drain<K,V>{Drain{cur:1,sm:self}}pub fn get(&self,key:K)->Option<&V>{let kd=key.data();self.slots.get(kd.idx as usize).filter(|slot|slot.version()==kd.version.get()).map(|slot|unsafe{slot.get_unchecked()})}pub unsafe fn get_unchecked(&self,key:K)->&V{debug_assert!(self.contains_key(key));let slot=self.slots.get_unchecked(key.data().idx as usize);slot.get_unchecked()}pub fn get_mut(&mut self,key:K)->Option<&mut V>{let kd=key.data();self.slots.get_mut(kd.idx as usize).filter(|slot|slot.version()==kd.version.get()).map(|slot|unsafe{slot.get_unchecked_mut()})}pub unsafe fn get_unchecked_mut(&mut self,key:K)->&mut V{debug_assert!(self.contains_key(key));let slot=self.slots.get_unchecked_mut(key.data().idx as usize);slot.get_unchecked_mut()}#[cfg(has_min_const_generics)]pub fn get_disjoint_mut<const N:usize>(&mut self,keys:[K;N])->Option<[&mut V;N]>{let mut ptrs:[MaybeUninit<*mut V>;N]=unsafe{MaybeUninit::uninit().assume_init()};let mut slot_versions:[MaybeUninit<u32>;N]=unsafe{MaybeUninit::uninit().assume_init()};let mut i=0;while i<N{let kd=keys[i].data();match self.slots.get_mut(kd.idx as usize){Some(Occupied{version,value})if*version==kd.version=>{ptrs[i]=MaybeUninit::new(&mut*value);slot_versions[i]=MaybeUninit::new(version.get());*version=NonZeroU32::new(2).unwrap();}_=>break,}i+=1;}for j in 0..i{let idx=keys[j].data().idx as usize;unsafe{match self.slots.get_mut(idx){Some(Occupied{version,..})=>{*version=NonZeroU32::new_unchecked(slot_versions[j].assume_init());}_=>unreachable_unchecked(),}}}if i==N{Some(unsafe{core::mem::transmute_copy::<_,[&mut V;N]>(&ptrs)})}else{None}}#[cfg(has_min_const_generics)]pub unsafe fn get_disjoint_unchecked_mut<const N:usize>(&mut self,keys:[K;N],)->[&mut V;N]{let mut ptrs:[MaybeUninit<*mut V>;N]=MaybeUninit::uninit().assume_init();for i in 0..N{ptrs[i]=MaybeUninit::new(self.get_unchecked_mut(keys[i]));}core::mem::transmute_copy::<_,[&mut V;N]>(&ptrs)}pub fn iter(&self)->Iter<K,V>{Iter{num_left:self.num_elems,slots:self.slots.iter().enumerate(),_k:PhantomData,}}pub fn iter_mut(&mut self)->IterMut<K,V>{IterMut{num_left:self.num_elems,slots:self.slots.iter_mut().enumerate(),_k:PhantomData,}}pub fn keys(&self)->Keys<K,V>{Keys{inner:self.iter()}}pub fn values(&self)->Values<K,V>{Values{inner:self.iter()}}pub fn values_mut(&mut self)->ValuesMut<K,V>{ValuesMut{inner:self.iter_mut(),}}pub fn entry(&mut self,key:K)->Option<Entry<K,V>>{if key.is_null(){return None;}let kd=key.data();self.slots.extend((self.slots.len()..=kd.idx as usize).map(|_|Slot::new_vacant()));let slot=unsafe{self.slots.get_unchecked(kd.idx as usize)};if kd.version.get()==slot.version(){Some(Entry::Occupied(OccupiedEntry{map:self,kd,_k:PhantomData,}))}else if is_older_version(kd.version.get(),slot.version()){None}else{Some(Entry::Vacant(VacantEntry{map:self,kd,_k:PhantomData,}))}}}impl<K:Key,V>Default for SecondaryMap<K,V>{fn default()->Self{Self::new()}}impl<K:Key,V>Index<K>for SecondaryMap<K,V>{type Output=V;fn index(&self,key:K)->&V{match self.get(key){Some(r)=>r,None=>panic!("invalid SecondaryMap key used"),}}}impl<K:Key,V>IndexMut<K>for SecondaryMap<K,V>{fn index_mut(&mut self,key:K)->&mut V{match self.get_mut(key){Some(r)=>r,None=>panic!("invalid SecondaryMap key used"),}}}impl<K:Key,V:PartialEq>PartialEq for SecondaryMap<K,V>{fn eq(&self,other:&Self)->bool{if self.len()!=other.len(){return false;}self.iter().all(|(key,value)|{other.get(key).map_or(false,|other_value|*value==*other_value)})}}impl<K:Key,V:Eq>Eq for SecondaryMap<K,V>{}impl<K:Key,V>FromIterator<(K,V)>for SecondaryMap<K,V>{fn from_iter<I:IntoIterator<Item=(K,V)>>(iter:I)->Self{let mut sec=Self::new();sec.extend(iter);sec}}impl<K:Key,V>Extend<(K,V)>for SecondaryMap<K,V>{fn extend<I:IntoIterator<Item=(K,V)>>(&mut self,iter:I){let iter=iter.into_iter();for(k,v)in iter{self.insert(k,v);}}}impl<'a,K:Key,V:'a+Copy>Extend<(K,&'a V)>for SecondaryMap<K,V>{fn extend<I:IntoIterator<Item=(K,&'a V)>>(&mut self,iter:I){let iter=iter.into_iter();for(k,v)in iter{self.insert(k,*v);}}}#[derive(Debug)]pub struct OccupiedEntry<'a,K:Key,V>{map:&'a mut SecondaryMap<K,V>,kd:KeyData,_k:PhantomData<fn(K)->K>,}#[derive(Debug)]pub struct VacantEntry<'a,K:Key,V>{map:&'a mut SecondaryMap<K,V>,kd:KeyData,_k:PhantomData<fn(K)->K>,}#[derive(Debug)]pub enum Entry<'a,K:Key,V>{Occupied(OccupiedEntry<'a,K,V>),Vacant(VacantEntry<'a,K,V>),}impl<'a,K:Key,V>Entry<'a,K,V>{pub fn or_insert(self,default:V)->&'a mut V{self.or_insert_with(||default)}pub fn or_insert_with<F:FnOnce()->V>(self,default:F)->&'a mut V{match self{Entry::Occupied(x)=>x.into_mut(),Entry::Vacant(x)=>x.insert(default()),}}pub fn key(&self)->K{match self{Entry::Occupied(entry)=>entry.kd.into(),Entry::Vacant(entry)=>entry.kd.into(),}}pub fn and_modify<F>(self,f:F)->Self where F:FnOnce(&mut V),{match self{Entry::Occupied(mut entry)=>{f(entry.get_mut());Entry::Occupied(entry)}Entry::Vacant(entry)=>Entry::Vacant(entry),}}}impl<'a,K:Key,V:Default>Entry<'a,K,V>{pub fn or_default(self)->&'a mut V{self.or_insert_with(Default::default)}}impl<'a,K:Key,V>OccupiedEntry<'a,K,V>{pub fn key(&self)->K{self.kd.into()}pub fn remove_entry(self)->(K,V){(self.kd.into(),self.remove())}pub fn get(&self)->&V{unsafe{self.map.get_unchecked(self.kd.into())}}pub fn get_mut(&mut self)->&mut V{unsafe{self.map.get_unchecked_mut(self.kd.into())}}pub fn into_mut(self)->&'a mut V{unsafe{self.map.get_unchecked_mut(self.kd.into())}}pub fn insert(&mut self,value:V)->V{replace(self.get_mut(),value)}pub fn remove(self)->V{let slot=unsafe{self.map.slots.get_unchecked_mut(self.kd.idx as usize)};self.map.num_elems-=1;match replace(slot,Slot::new_vacant()){Occupied{value,..}=>value,Vacant=>unsafe{unreachable_unchecked()},}}}impl<'a,K:Key,V>VacantEntry<'a,K,V>{pub fn key(&self)->K{self.kd.into()}pub fn insert(self,value:V)->&'a mut V{let slot=unsafe{self.map.slots.get_unchecked_mut(self.kd.idx as usize)};match replace(slot,Slot::new_occupied(self.kd.version.get(),value)){Occupied{..}=>{}Vacant=>self.map.num_elems+=1,}unsafe{slot.get_unchecked_mut()}}}#[derive(Debug)]pub struct Drain<'a,K:Key+'a,V:'a>{sm:&'a mut SecondaryMap<K,V>,cur:usize,}#[derive(Debug)]pub struct IntoIter<K:Key,V>{num_left:usize,slots:Enumerate<alloc::vec::IntoIter<Slot<V>>>,_k:PhantomData<fn(K)->K>,}#[derive(Debug)]pub struct Iter<'a,K:Key+'a,V:'a>{num_left:usize,slots:Enumerate<core::slice::Iter<'a,Slot<V>>>,_k:PhantomData<fn(K)->K>,}#[derive(Debug)]pub struct IterMut<'a,K:Key+'a,V:'a>{num_left:usize,slots:Enumerate<core::slice::IterMut<'a,Slot<V>>>,_k:PhantomData<fn(K)->K>,}#[derive(Debug)]pub struct Keys<'a,K:Key+'a,V:'a>{inner:Iter<'a,K,V>,}#[derive(Debug)]pub struct Values<'a,K:Key+'a,V:'a>{inner:Iter<'a,K,V>,}#[derive(Debug)]pub struct ValuesMut<'a,K:Key+'a,V:'a>{inner:IterMut<'a,K,V>,}impl<'a,K:Key,V>Iterator for Drain<'a,K,V>{type Item=(K,V);fn next(&mut self)->Option<(K,V)>{while let Some(slot)=self.sm.slots.get_mut(self.cur){let idx=self.cur;self.cur+=1;if let Occupied{value,version}=replace(slot,Slot::new_vacant()){self.sm.num_elems-=1;let key=KeyData::new(idx as u32,version.get()).into();return Some((key,value));}}None}fn size_hint(&self)->(usize,Option<usize>){(self.sm.len(),Some(self.sm.len()))}}impl<'a,K:Key,V>Drop for Drain<'a,K,V>{fn drop(&mut self){self.for_each(|_drop|{});}}impl<K:Key,V>Iterator for IntoIter<K,V>{type Item=(K,V);fn next(&mut self)->Option<(K,V)>{while let Some((idx,mut slot))=self.slots.next(){if let Occupied{value,version}=replace(&mut slot,Slot::new_vacant()){self.num_left-=1;let key=KeyData::new(idx as u32,version.get()).into();return Some((key,value));}}None}fn size_hint(&self)->(usize,Option<usize>){(self.num_left,Some(self.num_left))}}impl<'a,K:Key,V>Iterator for Iter<'a,K,V>{type Item=(K,&'a V);fn next(&mut self)->Option<(K,&'a V)>{while let Some((idx,slot))=self.slots.next(){if let Occupied{value,version}=slot{self.num_left-=1;let key=KeyData::new(idx as u32,version.get()).into();return Some((key,value));}}None}fn size_hint(&self)->(usize,Option<usize>){(self.num_left,Some(self.num_left))}}impl<'a,K:Key,V>Iterator for IterMut<'a,K,V>{type Item=(K,&'a mut V);fn next(&mut self)->Option<(K,&'a mut V)>{while let Some((idx,slot))=self.slots.next(){if let Occupied{value,version}=slot{let key=KeyData::new(idx as u32,version.get()).into();self.num_left-=1;return Some((key,value));}}None}fn size_hint(&self)->(usize,Option<usize>){(self.num_left,Some(self.num_left))}}impl<'a,K:Key,V>Iterator for Keys<'a,K,V>{type Item=K;fn next(&mut self)->Option<K>{self.inner.next().map(|(key,_)|key)}fn size_hint(&self)->(usize,Option<usize>){self.inner.size_hint()}}impl<'a,K:Key,V>Iterator for Values<'a,K,V>{type Item=&'a V;fn next(&mut self)->Option<&'a V>{self.inner.next().map(|(_,value)|value)}fn size_hint(&self)->(usize,Option<usize>){self.inner.size_hint()}}impl<'a,K:Key,V>Iterator for ValuesMut<'a,K,V>{type Item=&'a mut V;fn next(&mut self)->Option<&'a mut V>{self.inner.next().map(|(_,value)|value)}fn size_hint(&self)->(usize,Option<usize>){self.inner.size_hint()}}impl<'a,K:Key,V>IntoIterator for&'a SecondaryMap<K,V>{type Item=(K,&'a V);type IntoIter=Iter<'a,K,V>;fn into_iter(self)->Self::IntoIter{self.iter()}}impl<'a,K:Key,V>IntoIterator for&'a mut SecondaryMap<K,V>{type Item=(K,&'a mut V);type IntoIter=IterMut<'a,K,V>;fn into_iter(self)->Self::IntoIter{self.iter_mut()}}impl<K:Key,V>IntoIterator for SecondaryMap<K,V>{type Item=(K,V);type IntoIter=IntoIter<K,V>;fn into_iter(self)->Self::IntoIter{let len=self.len();let mut it=self.slots.into_iter().enumerate();it.next();IntoIter{num_left:len,slots:it,_k:PhantomData,}}}impl<'a,K:Key,V>FusedIterator for Iter<'a,K,V>{}impl<'a,K:Key,V>FusedIterator for IterMut<'a,K,V>{}impl<'a,K:Key,V>FusedIterator for Keys<'a,K,V>{}impl<'a,K:Key,V>FusedIterator for Values<'a,K,V>{}impl<'a,K:Key,V>FusedIterator for ValuesMut<'a,K,V>{}impl<'a,K:Key,V>FusedIterator for Drain<'a,K,V>{}impl<K:Key,V>FusedIterator for IntoIter<K,V>{}impl<'a,K:Key,V>ExactSizeIterator for Iter<'a,K,V>{}impl<'a,K:Key,V>ExactSizeIterator for IterMut<'a,K,V>{}impl<'a,K:Key,V>ExactSizeIterator for Keys<'a,K,V>{}impl<'a,K:Key,V>ExactSizeIterator for Values<'a,K,V>{}impl<'a,K:Key,V>ExactSizeIterator for ValuesMut<'a,K,V>{}impl<'a,K:Key,V>ExactSizeIterator for Drain<'a,K,V>{}impl<K:Key,V>ExactSizeIterator for IntoIter<K,V>{}}pub mod sparse_secondary{use crate::__cargo_equip::preludes::slotmap::*;use super::{is_older_version,Key,KeyData};#[cfg(all(nightly,any(doc,feature="unstable")))]use alloc::collections::TryReserveError;#[allow(unused_imports)]use core::mem::MaybeUninit;use std::collections::hash_map::{self,HashMap};use std::hash;use std::iter::{Extend,FromIterator,FusedIterator};use std::marker::PhantomData;use std::ops::{Index,IndexMut};#[derive(Debug,Clone)]struct Slot<T>{version:u32,value:T,}#[derive(Debug,Clone)]pub struct SparseSecondaryMap<K:Key,V,S:hash::BuildHasher=hash_map::RandomState>{slots:HashMap<u32,Slot<V>,S>,_k:PhantomData<fn(K)->K>,}impl<K:Key,V>SparseSecondaryMap<K,V,hash_map::RandomState>{pub fn new()->Self{Self::with_capacity(0)}pub fn with_capacity(capacity:usize)->Self{Self{slots:HashMap::with_capacity(capacity),_k:PhantomData,}}}impl<K:Key,V,S:hash::BuildHasher>SparseSecondaryMap<K,V,S>{pub fn with_hasher(hash_builder:S)->Self{Self{slots:HashMap::with_hasher(hash_builder),_k:PhantomData,}}pub fn with_capacity_and_hasher(capacity:usize,hash_builder:S)->Self{Self{slots:HashMap::with_capacity_and_hasher(capacity,hash_builder),_k:PhantomData,}}pub fn len(&self)->usize{self.slots.len()}pub fn is_empty(&self)->bool{self.slots.is_empty()}pub fn capacity(&self)->usize{self.slots.capacity()}pub fn reserve(&mut self,additional:usize){self.slots.reserve(additional);}#[cfg(all(nightly,any(doc,feature="unstable")))]#[cfg_attr(all(nightly,doc),doc(cfg(feature="unstable")))]pub fn try_reserve(&mut self,additional:usize)->Result<(),TryReserveError>{self.slots.try_reserve(additional)}pub fn contains_key(&self,key:K)->bool{let kd=key.data();self.slots.get(&kd.idx).map_or(false,|slot|slot.version==kd.version.get())}pub fn insert(&mut self,key:K,value:V)->Option<V>{if key.is_null(){return None;}let kd=key.data();if let Some(slot)=self.slots.get_mut(&kd.idx){if slot.version==kd.version.get(){return Some(std::mem::replace(&mut slot.value,value));}if is_older_version(kd.version.get(),slot.version){return None;}*slot=Slot{version:kd.version.get(),value,};return None;}self.slots.insert(kd.idx,Slot{version:kd.version.get(),value,},);None}pub fn remove(&mut self,key:K)->Option<V>{let kd=key.data();if let hash_map::Entry::Occupied(entry)=self.slots.entry(kd.idx){if entry.get().version==kd.version.get(){return Some(entry.remove_entry().1.value);}}None}pub fn retain<F>(&mut self,mut f:F)where F:FnMut(K,&mut V)->bool,{self.slots.retain(|&idx,slot|{let key=KeyData::new(idx,slot.version).into();f(key,&mut slot.value)})}pub fn clear(&mut self){self.slots.clear();}pub fn drain(&mut self)->Drain<K,V>{Drain{inner:self.slots.drain(),_k:PhantomData,}}pub fn get(&self,key:K)->Option<&V>{let kd=key.data();self.slots.get(&kd.idx).filter(|slot|slot.version==kd.version.get()).map(|slot|&slot.value)}pub unsafe fn get_unchecked(&self,key:K)->&V{debug_assert!(self.contains_key(key));self.get(key).unwrap_or_else(||core::hint::unreachable_unchecked())}pub fn get_mut(&mut self,key:K)->Option<&mut V>{let kd=key.data();self.slots.get_mut(&kd.idx).filter(|slot|slot.version==kd.version.get()).map(|slot|&mut slot.value)}pub unsafe fn get_unchecked_mut(&mut self,key:K)->&mut V{debug_assert!(self.contains_key(key));self.get_mut(key).unwrap_or_else(||core::hint::unreachable_unchecked())}#[cfg(has_min_const_generics)]pub fn get_disjoint_mut<const N:usize>(&mut self,keys:[K;N])->Option<[&mut V;N]>{let mut ptrs:[MaybeUninit<*mut V>;N]=unsafe{MaybeUninit::uninit().assume_init()};let mut i=0;while i<N{let kd=keys[i].data();match self.slots.get_mut(&kd.idx){Some(Slot{version,value})if*version==kd.version.get()=>{ptrs[i]=MaybeUninit::new(&mut*value);*version^=1;}_=>break,}i+=1;}for k in&keys[0..i]{match self.slots.get_mut(&k.data().idx){Some(Slot{version,..})=>{*version^=1;}_=>unsafe{core::hint::unreachable_unchecked()},}}if i==N{Some(unsafe{core::mem::transmute_copy::<_,[&mut V;N]>(&ptrs)})}else{None}}#[cfg(has_min_const_generics)]pub unsafe fn get_disjoint_unchecked_mut<const N:usize>(&mut self,keys:[K;N],)->[&mut V;N]{let mut ptrs:[MaybeUninit<*mut V>;N]=MaybeUninit::uninit().assume_init();for i in 0..N{ptrs[i]=MaybeUninit::new(self.get_unchecked_mut(keys[i]));}core::mem::transmute_copy::<_,[&mut V;N]>(&ptrs)}pub fn iter(&self)->Iter<K,V>{Iter{inner:self.slots.iter(),_k:PhantomData,}}pub fn iter_mut(&mut self)->IterMut<K,V>{IterMut{inner:self.slots.iter_mut(),_k:PhantomData,}}pub fn keys(&self)->Keys<K,V>{Keys{inner:self.iter()}}pub fn values(&self)->Values<K,V>{Values{inner:self.iter()}}pub fn values_mut(&mut self)->ValuesMut<K,V>{ValuesMut{inner:self.iter_mut(),}}pub fn entry(&mut self,key:K)->Option<Entry<K,V>>{if key.is_null(){return None;}let kd=key.data();if let hash_map::Entry::Occupied(o)=self.slots.entry(kd.idx){if o.get().version!=kd.version.get(){if is_older_version(o.get().version,kd.version.get()){o.remove();}else{return None;}}}Some(match self.slots.entry(kd.idx){hash_map::Entry::Occupied(inner)=>{Entry::Occupied(OccupiedEntry{inner,kd,_k:PhantomData,})}hash_map::Entry::Vacant(inner)=>Entry::Vacant(VacantEntry{inner,kd,_k:PhantomData,}),})}}impl<K,V,S>Default for SparseSecondaryMap<K,V,S>where K:Key,S:hash::BuildHasher+Default,{fn default()->Self{Self::with_hasher(Default::default())}}impl<K,V,S>Index<K>for SparseSecondaryMap<K,V,S>where K:Key,S:hash::BuildHasher,{type Output=V;fn index(&self,key:K)->&V{match self.get(key){Some(r)=>r,None=>panic!("invalid SparseSecondaryMap key used"),}}}impl<K,V,S>IndexMut<K>for SparseSecondaryMap<K,V,S>where K:Key,S:hash::BuildHasher,{fn index_mut(&mut self,key:K)->&mut V{match self.get_mut(key){Some(r)=>r,None=>panic!("invalid SparseSecondaryMap key used"),}}}impl<K,V,S>PartialEq for SparseSecondaryMap<K,V,S>where K:Key,V:PartialEq,S:hash::BuildHasher,{fn eq(&self,other:&Self)->bool{if self.len()!=other.len(){return false;}self.iter().all(|(key,value)|{other.get(key).map_or(false,|other_value|*value==*other_value)})}}impl<K,V,S>Eq for SparseSecondaryMap<K,V,S>where K:Key,V:Eq,S:hash::BuildHasher,{}impl<K,V,S>FromIterator<(K,V)>for SparseSecondaryMap<K,V,S>where K:Key,S:hash::BuildHasher+Default,{fn from_iter<I:IntoIterator<Item=(K,V)>>(iter:I)->Self{let mut sec=Self::default();sec.extend(iter);sec}}impl<K,V,S>Extend<(K,V)>for SparseSecondaryMap<K,V,S>where K:Key,S:hash::BuildHasher,{fn extend<I:IntoIterator<Item=(K,V)>>(&mut self,iter:I){let iter=iter.into_iter();for(k,v)in iter{self.insert(k,v);}}}impl<'a,K,V,S>Extend<(K,&'a V)>for SparseSecondaryMap<K,V,S>where K:Key,V:'a+Copy,S:hash::BuildHasher,{fn extend<I:IntoIterator<Item=(K,&'a V)>>(&mut self,iter:I){let iter=iter.into_iter();for(k,v)in iter{self.insert(k,*v);}}}#[derive(Debug)]pub struct OccupiedEntry<'a,K:Key,V>{inner:hash_map::OccupiedEntry<'a,u32,Slot<V>>,kd:KeyData,_k:PhantomData<fn(K)->K>,}#[derive(Debug)]pub struct VacantEntry<'a,K:Key,V>{inner:hash_map::VacantEntry<'a,u32,Slot<V>>,kd:KeyData,_k:PhantomData<fn(K)->K>,}#[derive(Debug)]pub enum Entry<'a,K:Key,V>{Occupied(OccupiedEntry<'a,K,V>),Vacant(VacantEntry<'a,K,V>),}impl<'a,K:Key,V>Entry<'a,K,V>{pub fn or_insert(self,default:V)->&'a mut V{self.or_insert_with(||default)}pub fn or_insert_with<F:FnOnce()->V>(self,default:F)->&'a mut V{match self{Entry::Occupied(x)=>x.into_mut(),Entry::Vacant(x)=>x.insert(default()),}}pub fn key(&self)->K{match self{Entry::Occupied(entry)=>entry.kd.into(),Entry::Vacant(entry)=>entry.kd.into(),}}pub fn and_modify<F>(self,f:F)->Self where F:FnOnce(&mut V),{match self{Entry::Occupied(mut entry)=>{f(entry.get_mut());Entry::Occupied(entry)}Entry::Vacant(entry)=>Entry::Vacant(entry),}}}impl<'a,K:Key,V:Default>Entry<'a,K,V>{pub fn or_default(self)->&'a mut V{self.or_insert_with(Default::default)}}impl<'a,K:Key,V>OccupiedEntry<'a,K,V>{pub fn key(&self)->K{self.kd.into()}pub fn remove_entry(self)->(K,V){(self.kd.into(),self.remove())}pub fn get(&self)->&V{&self.inner.get().value}pub fn get_mut(&mut self)->&mut V{&mut self.inner.get_mut().value}pub fn into_mut(self)->&'a mut V{&mut self.inner.into_mut().value}pub fn insert(&mut self,value:V)->V{std::mem::replace(self.get_mut(),value)}pub fn remove(self)->V{self.inner.remove().value}}impl<'a,K:Key,V>VacantEntry<'a,K,V>{pub fn key(&self)->K{self.kd.into()}pub fn insert(self,value:V)->&'a mut V{&mut self.inner.insert(Slot{version:self.kd.version.get(),value,}).value}}#[derive(Debug)]pub struct Drain<'a,K:Key+'a,V:'a>{inner:hash_map::Drain<'a,u32,Slot<V>>,_k:PhantomData<fn(K)->K>,}#[derive(Debug)]pub struct IntoIter<K:Key,V>{inner:hash_map::IntoIter<u32,Slot<V>>,_k:PhantomData<fn(K)->K>,}#[derive(Debug)]pub struct Iter<'a,K:Key+'a,V:'a>{inner:hash_map::Iter<'a,u32,Slot<V>>,_k:PhantomData<fn(K)->K>,}#[derive(Debug)]pub struct IterMut<'a,K:Key+'a,V:'a>{inner:hash_map::IterMut<'a,u32,Slot<V>>,_k:PhantomData<fn(K)->K>,}#[derive(Debug)]pub struct Keys<'a,K:Key+'a,V:'a>{inner:Iter<'a,K,V>,}#[derive(Debug)]pub struct Values<'a,K:Key+'a,V:'a>{inner:Iter<'a,K,V>,}#[derive(Debug)]pub struct ValuesMut<'a,K:Key+'a,V:'a>{inner:IterMut<'a,K,V>,}impl<'a,K:Key,V>Iterator for Drain<'a,K,V>{type Item=(K,V);fn next(&mut self)->Option<(K,V)>{self.inner.next().map(|(idx,slot)|{let key=KeyData::new(idx,slot.version).into();(key,slot.value)})}fn size_hint(&self)->(usize,Option<usize>){self.inner.size_hint()}}impl<'a,K:Key,V>Drop for Drain<'a,K,V>{fn drop(&mut self){self.for_each(|_drop|{});}}impl<K:Key,V>Iterator for IntoIter<K,V>{type Item=(K,V);fn next(&mut self)->Option<(K,V)>{self.inner.next().map(|(idx,slot)|{let key=KeyData::new(idx,slot.version).into();(key,slot.value)})}fn size_hint(&self)->(usize,Option<usize>){self.inner.size_hint()}}impl<'a,K:Key,V>Iterator for Iter<'a,K,V>{type Item=(K,&'a V);fn next(&mut self)->Option<(K,&'a V)>{self.inner.next().map(|(&idx,slot)|{let key=KeyData::new(idx,slot.version).into();(key,&slot.value)})}fn size_hint(&self)->(usize,Option<usize>){self.inner.size_hint()}}impl<'a,K:Key,V>Iterator for IterMut<'a,K,V>{type Item=(K,&'a mut V);fn next(&mut self)->Option<(K,&'a mut V)>{self.inner.next().map(|(&idx,slot)|{let key=KeyData::new(idx,slot.version).into();(key,&mut slot.value)})}fn size_hint(&self)->(usize,Option<usize>){self.inner.size_hint()}}impl<'a,K:Key,V>Iterator for Keys<'a,K,V>{type Item=K;fn next(&mut self)->Option<K>{self.inner.next().map(|(key,_)|key)}fn size_hint(&self)->(usize,Option<usize>){self.inner.size_hint()}}impl<'a,K:Key,V>Iterator for Values<'a,K,V>{type Item=&'a V;fn next(&mut self)->Option<&'a V>{self.inner.next().map(|(_,value)|value)}fn size_hint(&self)->(usize,Option<usize>){self.inner.size_hint()}}impl<'a,K:Key,V>Iterator for ValuesMut<'a,K,V>{type Item=&'a mut V;fn next(&mut self)->Option<&'a mut V>{self.inner.next().map(|(_,value)|value)}fn size_hint(&self)->(usize,Option<usize>){self.inner.size_hint()}}impl<'a,K,V,S>IntoIterator for&'a SparseSecondaryMap<K,V,S>where K:Key,S:hash::BuildHasher,{type Item=(K,&'a V);type IntoIter=Iter<'a,K,V>;fn into_iter(self)->Self::IntoIter{self.iter()}}impl<'a,K,V,S>IntoIterator for&'a mut SparseSecondaryMap<K,V,S>where K:Key,S:hash::BuildHasher,{type Item=(K,&'a mut V);type IntoIter=IterMut<'a,K,V>;fn into_iter(self)->Self::IntoIter{self.iter_mut()}}impl<K,V,S>IntoIterator for SparseSecondaryMap<K,V,S>where K:Key,S:hash::BuildHasher,{type Item=(K,V);type IntoIter=IntoIter<K,V>;fn into_iter(self)->Self::IntoIter{IntoIter{inner:self.slots.into_iter(),_k:PhantomData,}}}impl<'a,K:Key,V>FusedIterator for Iter<'a,K,V>{}impl<'a,K:Key,V>FusedIterator for IterMut<'a,K,V>{}impl<'a,K:Key,V>FusedIterator for Keys<'a,K,V>{}impl<'a,K:Key,V>FusedIterator for Values<'a,K,V>{}impl<'a,K:Key,V>FusedIterator for ValuesMut<'a,K,V>{}impl<'a,K:Key,V>FusedIterator for Drain<'a,K,V>{}impl<K:Key,V>FusedIterator for IntoIter<K,V>{}impl<'a,K:Key,V>ExactSizeIterator for Iter<'a,K,V>{}impl<'a,K:Key,V>ExactSizeIterator for IterMut<'a,K,V>{}impl<'a,K:Key,V>ExactSizeIterator for Keys<'a,K,V>{}impl<'a,K:Key,V>ExactSizeIterator for Values<'a,K,V>{}impl<'a,K:Key,V>ExactSizeIterator for ValuesMut<'a,K,V>{}impl<'a,K:Key,V>ExactSizeIterator for Drain<'a,K,V>{}impl<K:Key,V>ExactSizeIterator for IntoIter<K,V>{}}pub use crate::__cargo_equip::crates::slotmap::basic::SlotMap;pub use crate::__cargo_equip::crates::slotmap::dense::DenseSlotMap;pub use crate::__cargo_equip::crates::slotmap::hop::HopSlotMap;pub use crate::__cargo_equip::crates::slotmap::secondary::SecondaryMap;pub use crate::__cargo_equip::crates::slotmap::sparse_secondary::SparseSecondaryMap;use core::fmt::{self,Debug,Formatter};use core::num::NonZeroU32;#[deprecated(since="1.0.0",note="Slottable is not necessary anymore, slotmap now supports all types on stable.")]pub trait Slottable{}#[allow(deprecated)]impl<T>Slottable for T{}#[derive(Clone,Copy,PartialEq,Eq,PartialOrd,Ord,Hash)]pub struct KeyData{idx:u32,version:NonZeroU32,}impl KeyData{fn new(idx:u32,version:u32)->Self{debug_assert!(version>0);Self{idx,version:unsafe{NonZeroU32::new_unchecked(version|1)},}}fn null()->Self{Self::new(core::u32::MAX,1)}fn is_null(self)->bool{self.idx==core::u32::MAX}pub fn as_ffi(self)->u64{(u64::from(self.version.get())<<32)|u64::from(self.idx)}pub fn from_ffi(value:u64)->Self{let idx=value&0xffff_ffff;let version=(value>>32)|1;Self::new(idx as u32,version as u32)}}impl Debug for KeyData{fn fmt(&self,f:&mut Formatter)->fmt::Result{write!(f,"{}v{}",self.idx,self.version.get())}}impl Default for KeyData{fn default()->Self{Self::null()}}pub unsafe trait Key:From<KeyData>+Copy+Clone+Default+Eq+PartialEq+Ord+PartialOrd+core::hash::Hash+core::fmt::Debug{fn null()->Self{KeyData::null().into()}fn is_null(&self)->bool{self.data().is_null()}fn data(&self)->KeyData;}#[macro_export(local_inner_macros)]macro_rules!__cargo_equip_macro_def_slotmap_new_key_type{($(#[$outer:meta])*$vis:vis struct$name:ident;$($rest:tt)*)=>{$(#[$outer])*#[derive(Copy,Clone,Default,Eq,PartialEq,Ord,PartialOrd,Hash,Debug)]#[repr(transparent)]$vis struct$name($crate::__cargo_equip::crates::slotmap::KeyData);impl From<$crate::__cargo_equip::crates::slotmap::KeyData>for$name{fn from(k:$crate::__cargo_equip::crates::slotmap::KeyData)->Self{$name(k)}}unsafe impl$crate::__cargo_equip::crates::slotmap::Key for$name{fn data(&self)->$crate::__cargo_equip::crates::slotmap::KeyData{self.0}}$crate::__cargo_equip::crates::slotmap::__serialize_key!($name);$crate::__cargo_equip::crates::slotmap::new_key_type!($($rest)*);};()=>{}}macro_rules!new_key_type{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_slotmap_new_key_type!{$($tt)*})}macro_rules!__serialize_key{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_slotmap___serialize_key!{$($tt)*})}#[macro_export]macro_rules!__cargo_equip_macro_def_slotmap___serialize_key{($name:ty)=>{};}macro_rules!__serialize_key{($($tt:tt)*)=>(crate::__cargo_equip_macro_def_slotmap___serialize_key!{$($tt)*})}new_key_type!{#[doc=" The default slot map key type."]pub struct DefaultKey;}fn is_older_version(a:u32,b:u32)->bool{let diff=a.wrapping_sub(b);diff>=(1<<31)}}
    }

    pub(crate) mod macros {
        pub mod slotmap {pub use crate::{__cargo_equip_macro_def_slotmap___serialize_key as __serialize_key,__cargo_equip_macro_def_slotmap_new_key_type as new_key_type};}
    }

    pub(crate) mod prelude {pub use crate::__cargo_equip::{crates::*,macros::slotmap::*};}

    mod preludes {
        pub mod slotmap {pub(in crate::__cargo_equip)use crate::__cargo_equip::macros::slotmap::*;}
    }
}
